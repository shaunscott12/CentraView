/*
 * $RCSfile: ContactHelperEJB.java,v $    $Revision: 1.3 $  $Date: 2005/09/07 13:43:57 $ - $Author: mcallist $
 * 
 * The contents of this file are subject to the Open Software License
 * Version 2.1 (the "License"); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 * http://www.centraview.com/opensource/license.html
 * 
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * The Original Code is: CentraView Open Source. 
 * 
 * The developer of the Original Code is CentraView.  Portions of the
 * Original Code created by CentraView are Copyright (c) 2004 CentraView,
 * LLC; All Rights Reserved.  The terms "CentraView" and the CentraView
 * logos are trademarks and service marks of CentraView, LLC.
 */

package com.centraview.contact.helper;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Vector;

import javax.ejb.SessionBean;
import javax.ejb.SessionContext;
import javax.naming.Context;

import org.apache.log4j.Logger;

import com.centraview.common.CVDal;
import com.centraview.common.DDNameValue;

/**
 * @author CentraView, LLC.
 */
public class ContactHelperEJB implements SessionBean {
  private static Logger logger = Logger.getLogger(ContactHelperEJB.class);
  protected javax.ejb.SessionContext ctx;
  protected Context environment;
  private String dataSource = "MySqlDS";

  /**
   * In this Method data from the passed Address VO is Saved in Address Table
   * and Address Relate Table. The addressId or zero is returned (if something
   * didn't work out).
   * @param addressVO Address Value Object
   * @param contactId ContactID either EntityID or IndividualID.
   * @param contactType Contact Type
   * @param individualId Login User ID
   * @param updateEntityOrIndividual If true, then we will update the entity or
   *          Individual on basis of the contact type. If false, then we will
   *          not update either Entity or Individual.
   * @return the address ID of the inserted address or zero if something didn't
   *         work correctly
   */
  public int addAddress(AddressVO addressVO, int contactId, int contactType, int individualId,
      boolean updateEntityOrIndividual)
  {
    int addressId = 0;
    if (addressVO == null) {
      return addressId;
    }
    CVDal dl = new CVDal(this.dataSource);

    try {
      // Inser the address:
      // insert into
      // address(AddressType,Street1,Street2,City,State,Zip,Country,Website)
      // values(?,?,?,?,?,?,?,?)
      dl.setSql("contact.addaddress");
      dl.setInt(1, addressVO.getAddressType());
      dl.setString(2, addressVO.getStreet1());
      dl.setString(3, addressVO.getStreet2());
      dl.setString(4, addressVO.getCity());
      dl.setString(5, addressVO.getStateName());
      dl.setString(6, addressVO.getZip());
      dl.setString(7, addressVO.getCountryName());
      dl.setString(8, addressVO.getWebsite());
      dl.setInt(9, addressVO.getJurisdictionID());
      dl.executeUpdate();
      addressId = dl.getAutoGeneratedKey();
      dl.setSqlQueryToNull();

      if ((addressVO.getIsPrimary()).equals("YES")) {
        dl.setSql("contact.updaterelateaddresstonotprim");
        dl.setInt(1, contactType);
        dl.setInt(2, contactId);
        dl.executeUpdate();
        dl.setSqlQueryToNull();
      }

      // hook up the relation
      // INSERT INTO
      // addressrelate(Address,ContactType,Contact,AddressType,IsPrimary)
      // VALUES (?,?,?,?,?)
      dl.setSql("contact.addaddressrelate");
      dl.setInt(1, addressId);
      dl.setInt(2, contactType);
      dl.setInt(3, contactId);
      dl.setInt(4, addressVO.getAddressType());
      dl.setString(5, addressVO.getIsPrimary());
      dl.executeUpdate();
      if (updateEntityOrIndividual) {
        this.updateModified("address", contactId, individualId, addressId);
      }
    } catch (Exception e) {
      logger.error("[addAddress]: Exception", e);
    } finally {
      dl.destroy();
    }
    return addressId;
  }

  /**
   * In this method Method of Contact of ContactID id to be saved . Data is
   * Saved in following Table 1) MethodOfContact 2) MOCelate
   * @param moc MethodOfContact Value Object
   * @param contactId ContactID
   * @param contactType Contact Type
   * @param userId LoginUser ID.
   * @param updateEntityOrIndividual If true, then we will update the entity or
   *          Individual on basis of the contact type. If false, then we will
   *          not update either Entity or Individual.
   */
  public void addMOC(MethodOfContactVO moc, int contactId, int contactType, int userId,
      boolean updateEntityOrIndividual)
  {
    if (moc == null) {
      return;
    }

    CVDal dl = new CVDal(dataSource);
    try {
      // MOCType,Content,Note
      // MOCID,ContactType,ContactID,Primary
      dl.setSql("contact.addmoc");
      dl.setInt(1, moc.getMocType());
      dl.setString(2, moc.getContent());
      dl.setString(3, moc.getNote());
      dl.setString(4, moc.getSyncAs());
      dl.setString(5, moc.getMocOrder());

      dl.executeUpdate();

      int mocId = dl.getAutoGeneratedKey();
      dl.setSqlQueryToNull();

      dl.setSql("contact.AddMOCSyncAs");

      // ALLSQL.put("contact.AddMOCSyncAs","update methodofcontact ,mocrelate
      // set syncas = '' where methodofcontact.mocid = mocrelate.mocid and
      // mocrelate.contactid = ? and mocrelate.contacttype = ? and
      // mocrelate.mocid != ? and syncas = ? ");
      dl.setInt(1, contactId);
      dl.setInt(2, contactType);
      dl.setInt(3, mocId);
      dl.setString(4, moc.getSyncAs());
      dl.executeUpdate();
      dl.setSqlQueryToNull();

      dl.setSql("contact.addmocrelate");
      dl.setInt(1, mocId);
      dl.setInt(2, contactType);
      dl.setInt(3, contactId);
      dl.setString(4, moc.getIsPrimary());
      dl.executeUpdate();
      if (updateEntityOrIndividual) {
        this.updateModified("moc", contactId, userId, mocId);
      }
    } catch (Exception e) {
      logger.error("[addMOC]: Exception", e);
    } finally {
      dl.destroy();
    }
  } // end of addMOC method

  /**
   * Returns the primary address for a contact.
   * @param individualId Currently not user.
   * @param contactId The contactID of the contact to get the address for.
   * @param contactType The type of contact 1 for entity, 2 for individual.
   * @return An AddressVO of the primary address for the contact.
   */
  public AddressVO getPrimaryAddressForContact(int individualId, int contactId, int contactType)
  {
    AddressVO addressVO = new AddressVO();
    CVDal cvdal = new CVDal(dataSource);
    try {
      String addressQuery = "SELECT a.AddressID, a.AddressType, a.Street1, "
          + "a.Street2, a.City, a.State, a.Zip, a.Country, a.Website, "
          + "b.isPrimary, a.jurisdictionID FROM address a, addressrelate b WHERE a.AddressID = b.Address "
          + "AND b.isPrimary = 'YES' AND b.Contact=? AND b.contactType= ?";

      cvdal.setSqlQuery(addressQuery);
      cvdal.setInt(1, contactId);
      cvdal.setInt(2, contactType);
      Collection results = cvdal.executeQuery();
      addressVO = this.fillAddress(results);
    } // end of try block
    catch (Exception e) {
      logger.error("[getPrimaryAddressForContact]: Exception", e);
    } // end of catch block (Exception)
    finally {
      cvdal.destroy();
      cvdal = null;
    } // end of finally block
    return addressVO;
  } // end of getPrimaryAddressForContact method

  public Collection getPrimaryMOCForContact(int userId, int contactId, int contactType)
  {
    Vector moc = null;
    CVDal dl = new CVDal(dataSource);
    Collection col = null;
    try {
      dl.setSql("contact.getprimarymoc");
      dl.setInt(1, contactId);
      dl.setInt(2, contactType);
      col = dl.executeQuery();
    } finally {
      dl.destroy();
    }

    if (col != null) {
      moc = new Vector();

      Iterator it = col.iterator();

      while (it.hasNext()) {
        HashMap hm = (HashMap)it.next();
        MethodOfContactVO mc = new MethodOfContactVO();

        mc.setMocID(((Long)hm.get("mocid")).intValue());
        mc.setIsPrimary((String)hm.get("isPrimary"));
        mc.setNote((String)hm.get("Note"));
        mc.setContent((String)hm.get("Content"));
        mc.setMocType(((Long)hm.get("MOCType")).intValue());
        mc.setSyncAs((String)hm.get("syncas"));
        mc.setMocOrder((String)hm.get("MOCOrder"));

        moc.add(mc);
      }
    }

    return moc;
  }

  public Collection getAllCustomFieldsForContact(int userId, int contactId, int contactType)
  {
    // TO BE IMPLEMENTED BY IQ, USE UNION TO GET BOTH SCALAR AND MULTUIPLE DATA.
    Collection cf = null;
    CVDal dl = new CVDal(dataSource);
    Collection col = null;
    try {
      dl.setSql("contact.getcustomfields");
      dl.setInt(1, contactId);
      dl.setInt(2, contactType);

      col = dl.executeQuery();
    } finally {
      dl.destroy();
    }
    // Vector cf = new Vector();
    if (col != null) {
      Iterator it = col.iterator();

      while (it.hasNext()) {
        ;
      }
    }

    return cf;
  }

  /**
   * In this method All Method of Contact is getting for contactType and
   * contactID This method returns the Vector having collection of
   * MethodOfContact Object
   */
  public Collection getAllMOCForContact(int userId, int contactId, int contactType)
  {
    // NOTE: Actually making permissions work for this method will break Merge
    // and Purge
    // unless it allows Admin users to get everything.
    // So if you change this make it so the Admin user type can always get all
    // MOCs.
    Vector moc = null;
    CVDal dl = new CVDal(dataSource);
    Collection col = null;
    try {
      // "select a.mocid, a.MOCType, a.Content, a.Note, isPrimary from
      // methodofcontact a, mocrelate b where a.MOCID = b.MOCID and ContactID =
      // ? and ContactType= ?
      dl.setSql("contact.getallmoc");
      dl.setInt(1, contactId);
      dl.setInt(2, contactType);
      col = dl.executeQuery();
    } finally {
      dl.destroy();
    }
    HashMap mocTypes = this.getMOCTypeHashMap();
    if (col != null) {
      moc = new Vector();

      Iterator it = col.iterator();

      while (it.hasNext()) {
        HashMap hm = (HashMap)it.next();
        MethodOfContactVO mc = new MethodOfContactVO();
        mc.setMocID(((Number)hm.get("mocid")).intValue());
        mc.setIsPrimary((String)hm.get("isPrimary"));
        mc.setNote((String)hm.get("Note"));
        mc.setSyncAs((String)hm.get("syncas"));
        mc.setContent((String)hm.get("Content"));
        // Code to get the MOCType label from the DB and stick it on the VO
        int mocType = ((Number)hm.get("MOCType")).intValue();
        mc.setMocType(mocType);
        String mocTypeName = (String)mocTypes.get(String.valueOf(mocType));
        if (mocTypeName == null) {
          mocTypeName = "";
        }
        mc.setMocTypeName(mocTypeName);
        mc.setMocOrder((String)hm.get("MOCOrder"));
        mc.added(false);
        mc.updated(false);
        mc.delete(false);
        moc.add(mc);
      }
    }
    return moc;
  }

  /**
   * Set the associated session context. The container calls this method after
   * the instance creation. The enterprise Bean instance should store the
   * reference to the context object in an instance variable. This method is
   * called with no transaction context.
   */
  public void setSessionContext(SessionContext ctx)
  {
    this.ctx = ctx;
  }

  /**
   * Called by the container to create a session bean instance. Its parameters
   * typically contain the information the client uses to customize the bean
   * instance for its use. It requires a matching pair in the bean class and its
   * home interface.
   */
  public void ejbCreate()
  {}

  /**
   * A container invokes this method before it ends the life of the session
   * object. This happens as a result of a client's invoking a remove operation,
   * or when a container decides to terminate the session object after a
   * timeout. This method is called with no transaction context.
   */
  public void ejbRemove()
  {}

  /**
   * The activate method is called when the instance is activated from its
   * 'passive' state. The instance should acquire any resource that it has
   * released earlier in the ejbPassivate() method. This method is called with
   * no transaction context.
   */
  public void ejbActivate()
  {}

  /**
   * The passivate method is called before the instance enters the 'passive'
   * state. The instance should release any resources that it can re-acquire
   * later in the ejbActivate() method. After the passivate method completes,
   * the instance must be in a state that allows the container to use the Java
   * Serialization protocol to externalize and store away the instance's state.
   * This method is called with no transaction context.
   */
  public void ejbPassivate()
  {}

  /*
   * In this method the Address is Updated .
   */
  public int updateAddress(AddressVO addressVO, int contactId, int individualId,
      boolean updateEntityOrIndividual)
  {
    int returnValue = 0;
    if (addressVO == null) {
      return returnValue;
    }

    CVDal cvdal = new CVDal(dataSource);
    try {
      // UPDATE address SET street1 = ?, street2 = ?, city = ? ,state = ?, zip =
      // ?,
      // country = ?, website = ?, AddressType= ?, IsPrimary = ? WHERE AddressID
      // = ?
      cvdal.setSql("contact.updateaddress");
      cvdal.setString(1, addressVO.getStreet1());
      cvdal.setString(2, addressVO.getStreet2());
      cvdal.setString(3, addressVO.getCity());
      cvdal.setString(4, addressVO.getStateName());
      cvdal.setString(5, addressVO.getZip());
      cvdal.setString(6, addressVO.getCountryName());
      cvdal.setString(7, addressVO.getWebsite());
      cvdal.setInt(8, addressVO.getAddressType());
      cvdal.setInt(9, addressVO.getJurisdictionID());
      cvdal.setInt(10, addressVO.getAddressID());
      returnValue = cvdal.executeUpdate();
      if (updateEntityOrIndividual) {
        this.updateModified("address", contactId, individualId, addressVO.getAddressID());
      }

    } catch (Exception e) {
      logger.error("[updateAddress]: Exception", e);
    } finally {
      cvdal.destroy();
      cvdal = null;
    }
    return returnValue;
  }

  /**
   * Updates a related Address
   */
  public void updateRelateAddress(AddressVO addressVO, int contactType, int contactId)
  {
    if (addressVO == null) {
      return;
    }

    CVDal cvdal = new CVDal(dataSource);
    try {
      cvdal.setSql("contact.updateaddress");
      cvdal.setString(1, addressVO.getStreet1());
      cvdal.setString(2, addressVO.getStreet2());
      cvdal.setString(3, addressVO.getCity());
      cvdal.setString(4, addressVO.getStateName());
      cvdal.setString(5, addressVO.getZip());
      cvdal.setString(6, addressVO.getCountryName());
      cvdal.setString(7, addressVO.getWebsite());
      cvdal.setInt(8, addressVO.getAddressType());
      cvdal.setString(9, addressVO.getIsPrimary());
      cvdal.setInt(10, addressVO.getJurisdictionID());
      cvdal.setInt(11, addressVO.getAddressID());
      cvdal.executeUpdate();
      cvdal.setSqlQueryToNull();

      if ((addressVO.getIsPrimary()).equals("YES")) {
        cvdal.setSql("contact.updaterelateaddresstonotprim");
        cvdal.setInt(1, contactType);
        cvdal.setInt(2, contactId);
        cvdal.executeUpdate();
        cvdal.setSqlQueryToNull();
      }

      cvdal.setSql("contact.updaterelateaddress");
      cvdal.setInt(1, addressVO.getAddressType());
      cvdal.setString(2, addressVO.getIsPrimary());
      cvdal.setInt(3, addressVO.getAddressID());
      cvdal.setInt(4, contactType);
      cvdal.setInt(5, contactId);
      cvdal.executeUpdate();
    } catch (Exception e) {
      logger.error("[updateRelateAddress]: Exception", e);
    } finally {
      cvdal.destroy();
      cvdal = null;
    }
  } // end updateRelateAddress()

  /**
   * In this method Address is deleted from the database.
   * @param addressId The ID of the address to be deleted.
   * @param contactID Not Used.
   * @param userId Not Used.
   * @param updateEntityOrIndividual If true, then we will update the entity or
   *          Individual on basis of the contact type. If false, then we will
   *          not update either Entity or Individual.
   */
  public void deleteAddress(int addressId, int contactId, int userId,
      boolean updateEntityOrIndividual)
  {
    CVDal dl = new CVDal(dataSource);
    // The contactId is no longer used here. Pass in whatever you like,
    // Since we are wiping out the address from the address table, we
    // might as well kill all the related entries in address relate.
    // TODO remove the contactId parameter and clean up all referring code.
    try {
      dl.setSql("contact.deleteaddressrelate");
      dl.setInt(1, addressId);

      dl.executeUpdate();
      dl.setSqlQueryToNull();

      dl.setSql("contact.deleteaddress");
      dl.setInt(1, addressId);
      dl.executeUpdate();
      dl.clearParameters();
      if (updateEntityOrIndividual) {
        this.updateModified("address", contactId, userId, addressId);
      }

    } catch (Exception e) {
      logger.error("[deleteAddress]: Exception", e);
    } finally {
      dl.destroy();
      dl = null;
    } // end of finally block
  } // end of deleteAddress

  /**
   * In this method MethodOfContact table data is Updated.
   */
  public void updateMOC(MethodOfContactVO contactMethod, int contactId, int userId,
      boolean updateEntityOrIndividual)
  {
    if (contactMethod == null) {
      return;
    }
    CVDal dl = new CVDal(dataSource);
    try {
      // ALLSQL.put("contact.updateMOC","update methodofcontact set MOCType =
      // ?,Content = ? ,Note = ? where MOCID = ? ");
      dl.setSql("contact.updateMOCSyncAs");

      // ALLSQL.put("contact.updateMOCSyncAs","update methodofcontact
      // moc1,methodofcontact moc2,mocrelate mr1, mocrelate mr2 set moc1.syncas
      // = '' where moc2.mocid = mr1.mocid and mr1.contacttype = mr2.contacttype
      // and mr1.contactid = mr2.contactid and mr2.mocid = moc1.mocid and
      // moc2.mocid = ? and moc1.syncas = ? and moc2.syncas = moc1.syncas ");
      dl.setInt(1, contactMethod.getMocID());
      dl.setString(2, contactMethod.getSyncAs());
      dl.executeUpdate();
      dl.setSqlQueryToNull();

      dl.setSql("contact.updateMOC");
      dl.setInt(1, contactMethod.getMocType());
      dl.setString(2, contactMethod.getContent());
      dl.setString(3, contactMethod.getNote());
      dl.setString(4, contactMethod.getSyncAs());

      if (contactMethod.getMocOrder() == null) {
        MethodOfContactVO tempMethodOfContactVO = getMoc(contactMethod.getMocID());
        contactMethod.setMocOrder(tempMethodOfContactVO.getMocOrder());
      }

      dl.setString(5, contactMethod.getMocOrder());

      dl.setInt(6, contactMethod.getMocID());
      dl.executeUpdate();
      dl.clearParameters();

      dl.setSql("contact.updateMOCRelate");
      dl.setString(1, contactMethod.getIsPrimary());

      dl.setInt(2, contactMethod.getMocID());
      dl.executeUpdate();

      if (updateEntityOrIndividual) {
        this.updateModified("moc", contactId, userId, contactMethod.getMocID());
      }
    } catch (Exception e) {
      logger.error("[updateMOC]: Exception", e);
    } finally {
      dl.destroy();
    }
  }

  // end of updateMOC

  /*
   * In this method Method Of Contact is deleted from following table
   * 1)MethodOfContact 2)MOCRelate
   */
  public void deleteMOC(int mocId, int contactId, int userId, boolean updateEntityOrIndividual)
  {
    CVDal dl = new CVDal(dataSource);
    // TODO Remove the contactId, as we should just whack all references in the
    // mocrelate, since we are whacking the main record
    try {
      dl.setSql("contact.deletemocrelate");
      dl.setInt(1, mocId);

      dl.executeUpdate();
      dl.setSqlQueryToNull();

      dl.setSql("contact.deletemoc");
      dl.setInt(1, mocId);

      dl.executeUpdate();
      dl.clearParameters();
      if (updateEntityOrIndividual) {
        if (contactId > 0) {
          this.updateModified("moc", contactId, userId, mocId);
        }
      }
    } catch (Exception e) {
      logger.error("[deleteMOC]: Exception", e);
    } finally {
      dl.destroy();
      dl = null;
    }
  } // end of deleteMOC

  /**
   * Updates the modified date and modifiedby. When a contact method or address
   * is updated, it must alter the modified time of the individual or entity
   * record with which it is associated to the current time. If this does not
   * happen, sync is broken.
   */
  public void updateModified(String relateType, int contactID, int individualID, int recordID)
  {
    String query = null;
    CVDal cvdal = new CVDal(this.dataSource);

    try {
      cvdal.setSqlQueryToNull();

      if (relateType.equals("moc")) {
        query = "SELECT contacttype FROM mocrelate WHERE mocid=?";
      } else if (relateType.equals("address")) {
        query = "SELECT contacttype FROM addressrelate WHERE address=?";
      } else {
        return;
      }
      cvdal.setSqlQuery(query);
      cvdal.setInt(1, recordID);
      Collection colList = cvdal.executeQuery();

      cvdal.clearParameters();
      cvdal.setSqlQueryToNull();

      int contactType = 1; // set to 1 just in case something goes wrong (1 ==
      // entity)

      if (colList != null) {
        Iterator it = colList.iterator();
        if (it.hasNext()) {
          HashMap hm = (HashMap)it.next();
          contactType = ((Number)hm.get("contacttype")).intValue();
        }
      }

      if (contactType == 1) // Entity
      {
        query = "UPDATE entity SET ModifiedBy=?, Modified=NOW() WHERE entityID=?";
      } else if (contactType == 2) {
        // Individual
        query = "UPDATE individual SET ModifiedBy=?, Modified=NOW() wHERE individualID=?";
      }
      cvdal.setSqlQuery(query);
      cvdal.setInt(1, individualID);
      cvdal.setInt(2, contactID);
      cvdal.executeUpdate();
    } catch (Exception e) {
      logger.error("[updateModified]: Exception", e);
    } finally {
      cvdal.destroy();
      cvdal = null;
    }
  } // end updateModified

  public void updateModifiedBy(CustomFieldVO customField, int userId)
  {
    CVDal cvdl = new CVDal(dataSource);
    String strQuery = "select r.name as name from  cvtable r where r.tableid = "
        + customField.getRecordTypeID();

    cvdl.setSqlQuery(strQuery);
    Collection colList = cvdl.executeQuery();

    String name = null;
    if (colList != null) {

      Iterator it = colList.iterator();
      if (it.hasNext()) {

        HashMap hm = (HashMap)it.next();
        name = (String)hm.get("name");
      }
    }
    cvdl.destroy();
    cvdl = new CVDal(dataSource);
    if (name != null) {

      String updateQuery = "update " + name + " set ModifiedBy =  " + userId
          + ", Modified = concat(CURRENT_DATE, CURRENT_TIME) where " + name + "Id = "
          + customField.getRecordID();

      cvdl.setSqlQuery(updateQuery);
      cvdl.executeUpdate();
      cvdl.destroy();
    }
  }

  /**
   * This method returns a vector of DDNameValue objects. These objects contain
   * the State IDs and the State Names of all of the States in the database. The
   * first element in the vector is an empty DDNameValue object with the ID 0.
   * @see com.centraview.common.DDNameValue
   */
  public Vector getStates()
  {
    Vector statesVector = new Vector();
    CVDal dl = new CVDal(dataSource);

    try {
      dl.setSql("contact.getallstate");
      Collection col = dl.executeQuery();

      DDNameValue emptyValue = new DDNameValue(0, "");
      statesVector.add(emptyValue);
      if (col != null) {
        Iterator it = col.iterator();

        while (it.hasNext()) {
          HashMap hm = (HashMap)it.next();

          int id = ((Integer)hm.get("StateID")).intValue();
          String name = (String)hm.get("Name");
          DDNameValue stateValue = new DDNameValue(id, name);
          statesVector.add(stateValue);
        } // end of while loop (it.hasNext())
      } // end of if statement (col != null)
    } // end of try block
    catch (Exception e) {
      logger.error("[getStates]: Exception", e);
    } // end of catch block (Exception)
    finally {
      dl.clearParameters();
      dl.destroy();
    } // end of finally block

    return statesVector;
  } // end of getStates method

  /**
   * This method returns a vector of DDNameValue objects. These objects contain
   * the Country IDs and the Country Names of all of the Countries in the
   * database. The first element in the vector is an empty DDNameValue object
   * with the ID 0.
   * @see com.centraview.common.DDNameValue
   */
  public Vector getCountry()
  {
    Vector countryVector = new Vector();
    CVDal dl = new CVDal(dataSource);
    try {
      dl.setSql("contact.getallcountry");
      Collection col = dl.executeQuery();
      DDNameValue emptyValue = new DDNameValue(0, "");
      countryVector.add(emptyValue);
      if (col != null) {
        Iterator it = col.iterator();

        while (it.hasNext()) {
          HashMap hm = (HashMap)it.next();
          int id = ((Number)hm.get("CountryID")).intValue();
          String name = (String)hm.get("Name");
          DDNameValue countryValue = new DDNameValue(id, name);
          countryVector.add(countryValue);
        } // end of while loop (it.hasNext())
      } // end of if statement (col != null)
    } // end of try block
    catch (Exception e) {
      logger.error("[getCountry]: Exception", e);
    } // end of catch block (Exception)
    finally {
      dl.destroy();
      dl = null;
    } // end of finally block

    return countryVector;
  } // end of getCountry method

  public HashMap getEmployeeList()
  {
    Collection col = null;
    HashMap individualList = new HashMap();
    CVDal dl = new CVDal(dataSource);
    try {
      String sql = "SELECT i.IndividualID, CONCAT(i.FirstName, ' ', i.LastName) AS Name "
          + "FROM individual i WHERE i.Entity=1 UNION "
          + "SELECT u.IndividualID, CONCAT(i.FirstName, ' ', i.LastName) AS Name "
          + "FROM user u LEFT JOIN individual i ON "
          + "(u.IndividualID=i.IndividualID) WHERE u.usertype='EMPLOYEE'";
      dl.setSqlQuery(sql);
      col = dl.executeQuery();
      if (col != null) {
        Iterator it = col.iterator();

        while (it.hasNext()) {
          HashMap hm = (HashMap)it.next();
          int id = ((Long)hm.get("IndividualID")).intValue();
          String name = (String)hm.get("Name");
          individualList.put(name.trim(), id + "");
        }
      }
      // end of if
    } catch (Exception e) {
      logger.error("[getEmployeeList]: Exception", e);
    } finally {
      dl.destroy();
    }

    return individualList;
  }

  // end of getIndividualList

  public HashMap getEntityList(int listId)
  {
    Collection col = null;
    HashMap entityList = new HashMap();

    CVDal dl = new CVDal(dataSource);
    try {
      dl.setSqlQuery("select EntityID,Name from entity where list=" + listId);
      col = dl.executeQuery();
      if (col != null) {
        Iterator it = col.iterator();

        while (it.hasNext()) {
          HashMap hm = (HashMap)it.next();
          int id = ((Long)hm.get("EntityID")).intValue();
          String name = (String)hm.get("Name");
          entityList.put(name.trim(), id + "");
        }
      }
      // end of if
    } catch (Exception e) {
      logger.error("[getEntityList]: Exception", e);
    } finally {
      dl.destroy();
    }

    return entityList;
  }

  // end of getEntityList

  public void entityMove(int individualId, int listId, String entityIDs[])
  {
    /*
     * If the User is Administrator then he can move any records from one list
     * to another No one can move the Default Entity not even Admin can move it.
     * Administrator will be assigned by individualId -1 No admin user: they can
     * only move records which are owned by the user.
     */
    try {
      if (entityIDs != null) {

        String entityIds = "";
        for (int i = 0; i < entityIDs.length; i++) {
          if (!entityIDs[i].equals("1")) {
            entityIds += entityIDs[i];
            if (i != entityIDs.length - 1) {
              entityIds += ",";
            }
          }
        }

        String ownerFlag = "";
        if (individualId != -1) {
          ownerFlag = " and owner = " + individualId;
        }
        if (entityIds != null || !(entityIds.equals(""))) {
          CVDal dl = new CVDal(dataSource);
          try {
            dl.setSqlQuery("update individual set list=" + listId + " where entity in ("
                + entityIds + ") " + ownerFlag);
            dl.executeUpdate();
            dl.setSqlQueryToNull();

            dl.setSqlQuery("update entity set list=" + listId + " where entityID in (" + entityIds
                + ") " + ownerFlag);
            dl.executeUpdate();
          } finally {
            dl.destroy();
            dl = null;
          }
        }
      }
    } catch (Exception e) {
      logger.error("[entityMove]: Exception", e);
    }
  }

  public Vector getUsers()
  {
    Collection col = null;
    Vector vec = new Vector();
    CVDal dl = new CVDal(dataSource);
    try {
      dl
          .setSqlQuery("select usr.individualid,ind.FirstName Name , ind.LastName LName from individual ind , user usr where ind.individualid = usr.individualid order by LName asc");
      col = dl.executeQuery();
      if (col != null) {
        Iterator it = col.iterator();

        while (it.hasNext()) {
          HashMap hm = (HashMap)it.next();
          int id = ((Long)hm.get("individualid")).intValue();
          String name = (String)hm.get("Name");
          name = name + " " + (String)hm.get("LName");
          DDNameValue dd = new DDNameValue(id, name);
          vec.add(dd);
        }
      }
    } catch (Exception e) {
      logger.error("[getUsers]: Exception", e);
    } finally {
      dl.destroy();
    }
    return vec;
  } // end of getUsers

  public Vector getGroups()
  {
    Collection col = null;
    Vector vec = new Vector();

    CVDal dl = new CVDal(dataSource);
    try {
      // ALLSQL.put("contact.getallgroups","SELECT groupid,name Name FROM
      // grouptbl");
      dl.setSql("contact.getallgroups");
      col = dl.executeQuery();
      if (col != null) {
        Iterator it = col.iterator();

        while (it.hasNext()) {
          HashMap hm = (HashMap)it.next();

          int id = ((Long)hm.get("groupid")).intValue();
          String name = (String)hm.get("Name");
          DDNameValue dd = new DDNameValue(id, name);
          vec.add(dd);
        }
      }
      // end of if
    } catch (Exception e) {
      logger.error("[getGroups]: Exception", e);
    } finally {
      dl.destroy();
    }

    return vec;
  }

  // end of getGroups

  public Vector getMOCType()
  {
    Collection col = null;
    Vector vec = new Vector();
    CVDal dl = new CVDal(dataSource);
    try {
      // ALLSQL.put("contact.getallmoctype","Select MOCTypeID, Name from
      // moctype");
      dl.setSql("contact.getallmoctype");
      col = dl.executeQuery();
      if (col != null) {
        Iterator it = col.iterator();

        while (it.hasNext()) {
          HashMap hm = (HashMap)it.next();

          int id = ((Long)hm.get("MOCTypeID")).intValue();
          String name = (String)hm.get("Name");
          DDNameValue dd = new DDNameValue(id, name);
          vec.add(dd);
        } // end while
      } // end of if
    } catch (Exception e) {
      logger.error("[getMOCType]: Exception", e);
    } finally {
      dl.destroy();
    }
    return vec;
  } // end of getMOCType

  private HashMap getMOCTypeHashMap()
  {
    HashMap mocType = new HashMap();
    Collection col = null;
    CVDal dl = new CVDal(dataSource);
    try {
      // Select MOCTypeID, Name from moctype
      dl.setSql("contact.getallmoctype");
      col = dl.executeQuery();
      if (col != null) {
        Iterator it = col.iterator();

        while (it.hasNext()) {
          HashMap hm = (HashMap)it.next();
          int id = ((Number)hm.get("MOCTypeID")).intValue();
          String name = (String)hm.get("Name");
          mocType.put(String.valueOf(id), name);
        } // end while
      } // end of if
    } catch (Exception e) {
      logger.error("[getMOCTypeHashMap]: Exception", e);
    } finally {
      dl.destroy();
    }
    return mocType;
  } // end getMOCTypeArray

  /**
   * Returns the AddressVO from the database based on the addressId passed to
   * the method.
   * @param addressId The ID of the address to get.
   * @return The AddressVO from the database. If there is no address, it will
   *         return an empty AddressVO.
   */
  public AddressVO getAddress(int addressId)
  {
    CVDal dl = new CVDal(dataSource);
    AddressVO addressVO = new AddressVO();
    try {
      dl.setSql("contact.getaddress");
      dl.setInt(1, addressId);
      // Get isPrimary from addressrelate
      dl.setInt(2, addressId);
      Collection col = dl.executeQuery();
      addressVO = this.fillAddress(col);
    } // end of try block
    catch (Exception e) {
      logger.error("[getAddress]: Exception", e);
    } // end of catch block (Exception)
    finally {
      dl.destroy();
      dl = null;
    } // end of finally block
    return addressVO;
  } // end of getAddress block

  public AddressVO getRelatedAddress(int addressId, int contactType, int contactID)
  {
    CVDal dl = new CVDal(dataSource);
    AddressVO addressVO = new AddressVO();
    try {
      dl.setSql("contact.getrelateaddress");
      dl.setInt(1, addressId);
      dl.setInt(2, contactType);
      dl.setInt(3, contactID);
      Collection col = dl.executeQuery();
      addressVO = this.fillAddress(col);
    } catch (Exception e) {
      logger.error("[getRelatedAddress]: Exception", e);
    } finally {
      dl.destroy();
      dl = null;
    }
    return addressVO;
  } // end getRelatedAddress() method

  // it would be nice if the getPrimaryAddressForContact,
  // getPrimaryMOCForContact
  // can be merged in the below function
  public MethodOfContactVO getMoc(int mocId)
  {
    CVDal dl = new CVDal(dataSource);
    Collection col = null;
    try {
      dl.setSql("contact.getmoc");
      dl.setInt(1, mocId);

      col = dl.executeQuery();
    } finally {
      dl.destroy();
    }
    return fillMoc(col);
  }

  /**
   * helper method to fill a single address vo from a collection of hashmap
   * should be used with getPrimaryAddress Also. Will NOT return null.
   */
  private AddressVO fillAddress(Collection col)
  {
    AddressVO addressVO = new AddressVO();

    if (col != null) {
      Iterator it = col.iterator();

      if (it.hasNext()) {
        HashMap hm = (HashMap)it.next(); // expecting only one record
        addressVO = new AddressVO();
        addressVO.setAddressID(((Number)hm.get("AddressID")).intValue());
        addressVO.setStreet1((String)hm.get("Street1"));
        addressVO.setStreet2((String)hm.get("Street2"));
        addressVO.setCity((String)hm.get("City"));
        addressVO.setZip((String)hm.get("Zip"));
        addressVO.setWebsite((String)hm.get("Website"));
        addressVO.setAddressType(((Number)hm.get("AddressType")).intValue());
        addressVO.setCountryName((String)hm.get("Country"));
        addressVO.setStateName((String)hm.get("State"));
        addressVO.setIsPrimary((String)hm.get("isPrimary"));
        addressVO.setJurisdictionID(((Number)hm.get("jurisdictionID")).intValue());
      } // end of if statement (it.hasNext())
    } // end of if statement (col != null)
    return addressVO;
  }

  // helper method to fill single MOC VO
  // should be used with getPrimaryMethodOfContact Also
  private MethodOfContactVO fillMoc(Collection col)
  {
    MethodOfContactVO mc;

    if (col != null) {
      Iterator it = col.iterator();

      if (!it.hasNext()) {
        return null;
      }

      HashMap hm = (HashMap)it.next(); // expecting only one record

      mc = new MethodOfContactVO();

      mc.setMocID(((Long)hm.get("mocid")).intValue());
      mc.setIsPrimary((String)hm.get("isPrimary"));
      mc.setNote((String)hm.get("Note"));
      mc.setSyncAs((String)hm.get("syncas"));
      mc.setContent((String)hm.get("Content"));
      mc.setMocType(((Long)hm.get("MOCType")).intValue());
      mc.setMocOrder((String)hm.get("MOCOrder"));
    } else {
      return null;
    }
    return mc;
  }

  public Vector getSyncAs()
  {
    Collection col = null;
    Vector vec = new Vector();
    vec.add(new DDNameValue("", "--Select--"));

    try {
      CVDal dl = new CVDal(dataSource);

      // ALLSQL.put("contact.getallsyncas","SELECT syncas FROM syncmaster");
      dl.setSql("contact.getallsyncas");
      col = dl.executeQuery();
      dl.clearParameters();
      dl.destroy();

      if (col != null) {
        Iterator it = col.iterator();

        while (it.hasNext()) {
          HashMap hm = (HashMap)it.next();

          String name = (String)hm.get("syncas");

          DDNameValue dd = new DDNameValue(name, name);
          vec.add(dd);
        }
      }
      // end of if
    } catch (Exception e) {
      logger.error("[getSyncAs]: Exception", e);
    }

    return vec;
  }

  // end of getSyncAs

  public Vector getEmployeeIDs()
  {
    Collection col = null;
    Vector vec = new Vector();

    try {
      CVDal dl = new CVDal(dataSource);
      dl.setSql("contact.getemployees");
      col = dl.executeQuery();
      dl.clearParameters();
      dl.destroy();

      Long indID = null;

      if (col != null) {
        Iterator it = col.iterator();

        while (it.hasNext()) {
          HashMap hm = (HashMap)it.next();
          indID = (Long)hm.get("IndividualID");

          vec.add(indID.toString());
        }
      }
      // end of if
    } catch (Exception e) {
      logger.error("[getEmployeeIDs]: Exception", e);
    }

    return vec;
  }

  /**
   * @author Kevin McAllister <kevin@centraview.com>This simply sets the target
   *         datasource to be used for DB interaction
   * @param ds A string that contains the cannonical JNDI name of the datasource
   */
  public void setDataSource(String ds)
  {
    this.dataSource = ds;
  }

  /**
   * This method returns whether an individualID is also a user in the system.
   * @param individualID The individualID to check to see if it's a user.
   * @return true if the individual is also a user, false otherwise.
   */
  public boolean isIndividualAUser(int individualID)
  {
    boolean isUser = false;
    CVDal dataConnection = new CVDal(this.dataSource);
    try {
      dataConnection.setSql("contact.checkindividualasUser");
      dataConnection.setInt(1, individualID);

      Collection resultsCollection = dataConnection.executeQuery();
      if (resultsCollection != null) {
        Iterator it = resultsCollection.iterator();
        if (it.hasNext()) {
          isUser = true;
        } // end of if statement (it.hasNext())
      } // end of if statement (resultsCollection != null)
    } // end of try block
    catch (Exception e) {
      logger.error("[isIndividualAUser]: Exception", e);
    } // end of catch block (Exception)
    finally {
      dataConnection.clearParameters();
      dataConnection.destroy();
      dataConnection = null;
    } // end of finally block
    return isUser;
  } // end of isIndividualAUser method

  /**
   * This method returns concated FirstName and LastName Of the Individual
   * @param individualID The individualID to collect the Firstname and Lastname
   * @return individualName The individualName is the concatination of FirstName
   *         and LastName
   */
  public String getIndividualName(int individualID)
  {
    String individualName = "";
    CVDal dl = new CVDal(dataSource);
    try {
      String individualQuery = "select individualid, concat(FirstName,' ',LastName) IndividualName from individual where individualid = ?";

      dl.setSqlQuery(individualQuery);
      dl.setInt(1, individualID);
      Collection col = dl.executeQuery();

      if (col != null) {
        Iterator it = col.iterator();
        while (it.hasNext()) {
          HashMap hm = (HashMap)it.next();
          individualName = (String)hm.get("IndividualName");
        }// end of while (it.hasNext())
      }// end of if (col != null)
    } catch (Exception e) {
      logger.error("[getIndividualName]: Exception", e);
    } // end of catch block (Exception)
    finally {
      dl.destroy();
      dl = null;
    } // end of finally block
    return individualName;
  }

  /**
   * This method returns the Entity's Name
   * @param entityID The (int)entityID to collect the Entity's Name
   * @return entityName The Entity's Name as a String
   */
  public String getEntityName(int entityID)
  {
    String entityName = "";
    CVDal dl = new CVDal(dataSource);
    try {
      String entityQuery = "SELECT name FROM entity WHERE entityid = ?";
      dl.setSqlQuery(entityQuery);
      dl.setInt(1, entityID);
      Collection col = dl.executeQuery();
      if (col != null) {
        Iterator it = col.iterator();
        while (it.hasNext()) {
          HashMap hm = (HashMap)it.next();
          entityName = (String)hm.get("name");
        }// end of while (it.hasNext())
      }// end of if (col != null)
    } finally {
      dl.destroy();
      dl = null;
    } // end of finally block
    return entityName;
  }

  public Vector getCustomerPrimaryAddressForContact(int individualId, int contactId, int contactType)
  {
    Vector addressVector = new Vector();
    CVDal dl = new CVDal(dataSource);
    try {
      String addressQuery = "SELECT a.AddressID, a.AddressType, a.Street1, "
          + "a.Street2, a.City, a.State, a.Zip, a.Country, a.Website, "
          + "b.IsPrimary FROM address a, addressrelate b WHERE a.AddressID = b.Address "
          + "AND b.isPrimary = 'YES' AND b.Contact=? AND b.contactType= ?";

      dl.setSqlQuery(addressQuery);
      dl.setInt(1, contactType);
      dl.setInt(2, contactId);
      Collection results = dl.executeQuery();

      if (results != null) {
        Iterator it = results.iterator();
        while (it.hasNext()) {
          AddressVO addressVO = new AddressVO();
          HashMap resultMap = (HashMap)it.next();

          addressVO.setAddressID(((Long)resultMap.get("AddressID")).intValue());
          addressVO.setStreet1((String)resultMap.get("Street1"));
          addressVO.setStreet2((String)resultMap.get("Street2"));
          addressVO.setCity((String)resultMap.get("City"));
          addressVO.setStateName((String)resultMap.get("State"));
          addressVO.setZip((String)resultMap.get("Zip"));
          addressVO.setCountryName((String)resultMap.get("Country"));
          addressVO.setWebsite((String)resultMap.get("Website"));
          addressVO.setAddressType(((Long)resultMap.get("AddressType")).intValue());
          addressVO.setIsPrimary((String)resultMap.get("isPrimary"));
          addressVector.addElement(addressVO);
        } // end of while loop (it.hasNext())
      } // end of if statement (col != null)
    } // end of try block
    catch (Exception e) {
      logger.error("[getCustomerPrimaryAddressForContact]: Exception", e);
    } // end of catch block (Exception)
    finally {
      dl.destroy();
      dl = null;
    } // end of the finally block
    return addressVector;
  } // end of getCustomerPrimaryAddressForContact method

  /**
   * This method returns the HashMap with EntityID and Associated IndividualID
   * @param emailAddress The emailAddress to collect the EntityID and
   *          IndividualID
   */
  public HashMap getContactInfoForEmailAddress(String emailAddress)
  {

    HashMap contactInfo = new HashMap();

    CVDal dl = new CVDal(dataSource);
    try {

      String mocContactQuery = "select mocrelate.ContactID,mocrelate.ContactType from "
          + " mocrelate left join methodofcontact moc on "
          + " moc.Content=? where mocrelate.MOCID=moc.MOCID;";

      dl.setSqlQuery(mocContactQuery);
      dl.setString(1, emailAddress);
      Collection results = dl.executeQuery();
      dl.clearParameters();

      int contactType = 0;
      int contactID = 0;

      if (results != null) {
        Iterator it = results.iterator();
        while (it.hasNext()) {
          HashMap resultMap = (HashMap)it.next();
          contactID = ((Number)resultMap.get("ContactID")).intValue();
          contactType = ((Number)resultMap.get("ContactType")).intValue();
        } // end of while loop (it.hasNext())
      } // end of if statement (col != null)

      if (contactID != 0) {
        String contactQuery = "";
        if (contactType == 2) {
          contactQuery = "select IndividualID ,Entity EntityID from individual where IndividualID=?";
        } else {
          contactQuery = "select e.EntityID,i.IndividualID from entity e LEFT JOIN "
              + "individual i ON e.entityid=i.entity where e.EntityID=? "
              + "and PrimaryContact='YES';";
        }

        dl.setSqlQuery(contactQuery);
        dl.setInt(1, contactID);
        results = dl.executeQuery();
        dl.clearParameters();

        if (results != null) {
          Iterator it = results.iterator();
          while (it.hasNext()) {
            contactInfo = (HashMap)it.next();
          } // end of while loop (it.hasNext())
        } // end of if statement (col != null)
      }// if (contactID != 0)
    } // end of try block
    catch (Exception e) {
      logger.error("[getContactInfoForEmailAddress]: Exception", e);
    } // end of catch block (Exception)
    finally {
      dl.destroy();
      dl = null;
    } // end of the finally block
    return contactInfo;
  }// end of getContactInfoForEmailAddress(String emailAddress)

  /**
   * This method returns the ArrayList with collection of all the email address
   * belonging to the individuals.
   * @param individualIDs The individualIDs is collection od individualid
   *          seperated by comma.
   * @return toList The ArrayList with collection of all the email address
   *         belonging to the individuals.
   */
  public ArrayList getEmailContactForIndividuals(String individualIDs)
  {

    ArrayList toList = new ArrayList();
    CVDal cvdal = new CVDal(dataSource);
    try {
      String strSQL = "SELECT moc.Content emailAddress FROM methodofcontact moc LEFT JOIN "
          + "mocrelate mocrel ON (mocrel.MOCID=moc.MOCID) AND moc.MOCType=1 "
          + "WHERE mocrel.ContactID IN (" + individualIDs + ") AND mocrel.ContactType=2 ";
      cvdal.setSqlQuery(strSQL);
      Collection col = cvdal.executeQuery();
      if (col != null) {
        Iterator it = col.iterator();
        while (it.hasNext()) {
          HashMap hm = (HashMap)it.next();
          String emailAddress = (String)hm.get("emailAddress");
          if (emailAddress != null && !emailAddress.equals("")) {
            toList.add(emailAddress);
          }
        }
      }
    } catch (Exception e) {
      logger.error("[getEmailContactForIndividuals]: Exception", e);
    } finally {
      cvdal.destroy();
      cvdal = null;
    } // end of the finally block
    return toList;
  }// end of getContactInfoForEmailAddress(String emailAddress)

  /**
   * This method returns the entity ID for the associated Individual.
   * @param individualID The individualID is for the Individual.
   * @return toList The entityID for the Associated Individual.
   */
  public int getEntityIDForIndividual(int individualID)
  {
    int entityID = 0;
    CVDal cvdal = new CVDal(dataSource);
    try {
      String strSQL = "select entity as EntityID from individual where IndividualID="
          + individualID;
      cvdal.setSqlQuery(strSQL);
      Collection col = cvdal.executeQuery();
      if (col != null) {
        Iterator it = col.iterator();
        while (it.hasNext()) {
          HashMap hm = (HashMap)it.next();
          entityID = ((Number)hm.get("EntityID")).intValue();
        }// end of while( it.hasNext() )
      }// end of if(col != null){
    } // end of try block
    catch (Exception e) {
      logger.error("[getEntityIDForIndividual]: Exception", e);
    } // end of catch block (Exception)
    finally {
      cvdal.destroy();
      cvdal = null;
    } // end of the finally block
    return entityID;
  }// end of getEntityIDForIndividual(int individualID)

  /**
   * This method set the JurisdictionID for the Associated Address.
   * @param addressID The addressID is for the Address.
   * @param jurisdictionID The jurisdictionID is for the Address.
   * @return void.
   */
  public void setJurisdictionForAddress(int addressID, int jurisdictionID)
  {
    CVDal cvdal = new CVDal(dataSource);
    try {
      String strSQL = "update address set jurisdictionID=? where AddressID=?";
      cvdal.setSqlQuery(strSQL);
      cvdal.setInt(1, jurisdictionID);
      cvdal.setInt(2, addressID);
      cvdal.executeUpdate();
    } // end of try block
    catch (Exception e) {
      logger.error("[setJurisdictionForAddress]: Exception", e);
    } // end of catch block (Exception)
    finally {
      cvdal.destroy();
      cvdal = null;
    } // end of the finally block
  }// end of setJurisdictionForAddress(int addressID,int jurisdictionID){

  /**
   * This method returns the String with the email address belonging to the
   * individual/Entity.
   * @param contactID You can pass either EntityID or IndividualID and get their
   *          primary emailAddress.
   * @param contactType It will define wheather you are looking for the Entity
   *          or Individual EmailAddress.
   * @return emailAddress It returns the emailAddress belonging to the
   *         individual/Entity.
   */
  public String getPrimaryEmailAddress(int contactID, int contactType)
  {

    String emailAddress = null;
    CVDal cvdal = new CVDal(dataSource);
    try {
      String strSQL = "select moc.Content emailAddress from methodofcontact moc left join mocrelate mocrel on mocrel.MOCID=moc.MOCID and moc.MOCType=1 "
          + " where mocrel.ContactID = "
          + contactID
          + " and mocrel.ContactType="
          + contactType
          + " and mocrel.isPrimary = 'YES'";
      cvdal.setSqlQuery(strSQL);
      Collection col = cvdal.executeQuery();
      if (col != null) {
        Iterator it = col.iterator();
        while (it.hasNext()) {
          HashMap hm = (HashMap)it.next();
          emailAddress = (String)hm.get("emailAddress");
        }// end of while( it.hasNext() )
      }// end of if(col != null){
    } // end of try block
    catch (Exception e) {
      logger.error("[getPrimaryEmailAddress]: Exception", e);
    } // end of catch block (Exception)
    finally {
      cvdal.destroy();
      cvdal = null;
    } // end of the finally block
    return emailAddress;
  }// end of getPrimaryEmailAddress(int contactID,int contactType)
}
